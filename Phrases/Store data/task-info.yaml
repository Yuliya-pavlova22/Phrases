type: edu
files:
- name: src/main/java/org/hyperskill/phrases/MainActivity.kt
  visible: true
  text: |-
    package org.hyperskill.phrases

    import android.os.Bundle
    import androidx.appcompat.app.AppCompatActivity

    class MainActivity : AppCompatActivity() {
        override fun onCreate(savedInstanceState: Bundle?) {
            super.onCreate(savedInstanceState)
            setContentView(R.layout.activity_main)
        }
    }
  learner_created: false
- name: src/main/res/drawable/ic_launcher_background.xml
  visible: true
  learner_created: false
- name: src/main/res/drawable-v24/ic_launcher_foreground.xml
  visible: true
  learner_created: false
- name: src/main/res/layout/activity_main.xml
  visible: true
  learner_created: false
- name: src/main/res/mipmap-anydpi-v26/ic_launcher.xml
  visible: true
  learner_created: false
- name: src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml
  visible: true
  learner_created: false
- name: src/main/res/values/colors.xml
  visible: true
  learner_created: false
- name: src/main/res/values/strings.xml
  visible: true
  learner_created: false
- name: src/main/res/values/styles.xml
  visible: true
  learner_created: false
- name: src/main/AndroidManifest.xml
  visible: true
  learner_created: false
- name: src/test/java/org/hyperskill/phrases/internals/AbstractUnitTest.kt
  visible: false
  text: |-
    package org.hyperskill.phrases.internals

    import android.app.Activity
    import android.app.AlertDialog
    import android.app.Dialog
    import android.content.Context
    import android.content.Intent
    import android.database.sqlite.SQLiteDatabase
    import android.database.sqlite.SQLiteOpenHelper
    import android.os.Bundle
    import android.view.View
    import androidx.recyclerview.widget.RecyclerView
    import org.junit.Assert.*
    import org.robolectric.Robolectric
    import org.robolectric.Shadows.shadowOf
    import org.robolectric.android.controller.ActivityController
    import org.robolectric.shadow.api.Shadow
    import org.robolectric.shadows.ShadowActivity
    import org.robolectric.shadows.ShadowAlertDialog
    import org.robolectric.shadows.ShadowLooper
    import org.robolectric.shadows.ShadowToast
    import java.time.Duration

    // version 1.1
    abstract class AbstractUnitTest<T : Activity>(clazz: Class<T>) {

        /**
         * Setup and control activities and their lifecycle
         */
        val activityController: ActivityController<T> by lazy {
            Robolectric.buildActivity(clazz)
        }

        /**
         * The activity being tested.
         *
         * It is the @RealObject of the shadowActivity
         */
        val activity : Activity by lazy {
            activityController.get()
        }

        /**
         * A Roboletric shadow object of the Activity class, contains helper methods to deal with
         * testing activities like setting permissions, peeking results of launched activities for result,
         * retrieving shown dialogs, intents and others.
         *
         * If you don't know what shadows are you can have a better understanding on that reading this
         * on roboletric documentation: http://robolectric.org/extending/
         *
         * Understanding Shadows is fundamental for Roboletric, things are not what they appear to be on
         * Roboletric because running a code on the jvm is not the same as running the code on a real/emulated device.
         * Code that expects to eventually talk to the machine won't have the machine they expect to have to talk to.
         * Shadow is how Roboletric makes things possible, they impersonate @RealObject and act when @RealObject is expected to act.
         *
         * Things in Roboletric are not what they appear to be.
         * It is possible to not notice it for the most part, but it will be essential for some other parts
         */
        val shadowActivity: ShadowActivity by lazy {
            Shadow.extract(activity)
        }

        /**
         * A Roboletric shadow object of the mainLooper. Handles enqueued runnables and also the passage of time.
         *
         * Usually used with .idleFor(someDurationValue) or .runToEndOfTasks()
         */
        val shadowLooper: ShadowLooper by lazy {
            shadowOf(activity.mainLooper)
        }

        /**
         * Decorate your test code with this method to ensure better error messages displayed
         * when tests are run with check button and exceptions are thrown by user implementation.
         *
         * returns a value for convenience use, like in tests that involve navigation between Activities
         */
        fun <ReturnValue> testActivity(arguments: Intent = Intent(), savedInstanceState: Bundle = Bundle(), testCodeBlock: (Activity) -> ReturnValue): ReturnValue {
            try {
                activity.intent =  arguments
                activityController.setup(savedInstanceState)
            } catch (ex: Exception) {
                throw AssertionError("Exception, test failed on activity creation with $ex\n${ex.stackTraceToString()}")
            }

            return try {
                testCodeBlock(activity)
            } catch (ex: Exception) {
                throw AssertionError("Exception. Test failed on activity execution with $ex\n${ex.stackTraceToString()}")
            }
        }

        /**
         * Use this method to find views.
         *
         * The view existence will be assert before being returned
         */
        inline fun <reified T> Activity.findViewByString(idString: String): T {
            val id = this.resources.getIdentifier(idString, "id", this.packageName)
            val view: View? = this.findViewById(id)

            val idNotFoundMessage = "View with id \"$idString\" was not found"
            val wrongClassMessage = "View with id \"$idString\" is not from expected class. " +
                    "Expected ${T::class.java.simpleName} found ${view?.javaClass?.simpleName}"

            assertNotNull(idNotFoundMessage, view)
            assertTrue(wrongClassMessage, view is T)

            return view as T
        }

        /**
         * Use this method to find views.
         *
         * The view existence will be assert before being returned
         */
        inline fun <reified T> View.findViewByString(idString: String): T {
            val id = this.resources.getIdentifier(idString, "id", context.packageName)
            val view: View? = this.findViewById(id)

            val idNotFoundMessage = "View with id \"$idString\" was not found"
            val wrongClassMessage = "View with id \"$idString\" is not from expected class. " +
                    "Expected ${T::class.java.simpleName} found ${view?.javaClass?.simpleName}"

            assertNotNull(idNotFoundMessage, view)
            assertTrue(wrongClassMessage, view is T)

            return view as T
        }

        /**
         * Use this method to perform clicks. It will also advance the clock millis milliseconds and run
         * enqueued Runnable scheduled to run on main looper in that timeframe.
         * Default value for millis is 500
         *
         * Internally it calls performClick() and shadowLooper.idleFor(millis)
         */
        fun View.clickAndRun(millis: Long = 500){
            this.performClick()
            shadowLooper.idleFor(Duration.ofMillis(millis))
        }

        /**
         * Asserts that the last message toasted is the expectedMessage.
         * Assertion fails if no toast is shown with null actualLastMessage value.
         */
        fun assertLastToastMessageEquals(errorMessage: String, expectedMessage: String,) {
            val actualLastMessage: String? = ShadowToast.getTextOfLatestToast()
            assertEquals(errorMessage, expectedMessage, actualLastMessage)
        }

        /**
         * Use this method to retrieve the latest AlertDialog.
         *
         * The existence of such AlertDialog will be asserted before returning.
         *
         * Robolectric only supports android.app.AlertDialog, test will not be
         * able to find androidx.appcompat.app.AlertDialog.
         *
         * - Important!!! :
         * When writing stage description state explicitly the correct version that should be imported
         */
        fun getLatestDialog(): AlertDialog {
            val latestAlertDialog = ShadowAlertDialog.getLatestAlertDialog()

            assertNotNull(
                "There was no AlertDialog found. Make sure to import android.app.AlertDialog version",
                latestAlertDialog
            )

            return latestAlertDialog!!
        }

        /**
         *  Makes assertions on the contents of the RecyclerView.
         *
         *  Asserts that the size matches the size of fakeResultList and then
         *  calls assertItems for each item of the list with the itemViewSupplier
         *  so that it is possible to make assertions on that itemView.
         *
         *  Take attention to refresh references to views coming from itemView since RecyclerView
         *  can change the instance of View for a determinate list item after an update of the list
         *  (ex: calling notifyItemChanged and similar methods).
         */
        fun <T> RecyclerView.assertListItems(
            fakeResultList: List<T>,
            assertItems: (itemViewSupplier: () -> View, position: Int, item: T) -> Unit
        ) : Unit {

            assertNotNull("Your recycler view adapter should not be null", this.adapter)

            val expectedSize = fakeResultList.size

            val actualSize = this.adapter!!.itemCount
            assertEquals("Incorrect number of list items", expectedSize, actualSize)

            if(expectedSize == 0) {
                return
            } else if(expectedSize > 0) {
                val firstItemViewHolder = (0 until expectedSize)
                    .asSequence()
                    .mapNotNull {  this.findViewHolderForAdapterPosition(it) }
                    .firstOrNull()
                    ?: throw AssertionError("No item is being displayed on songList RecyclerView, is it big enough to display one item?")

                val listHeight = firstItemViewHolder.itemView.height * (expectedSize + 1)

                for((i, song) in fakeResultList.withIndex()) {
                    // setting height to ensure that all items are inflated. Height might change after assertItems, keep statement inside loop.
                    this.layout(0,0, this.width, listHeight)  // may increase clock time

                    val itemViewSupplier = {
                        scrollToPosition(i)
                        findViewHolderForAdapterPosition(i)?.itemView
                            ?: throw AssertionError("Could not find list item with index $i")
                    }
                    assertItems(itemViewSupplier, i, song)
                }

            } else {
                throw IllegalStateException("size assertion was not effective")
            }
        }


        /**
         * Use this class to get a testing database.
         *
         * example use-cases:
         * TestDatabaseFactory().writableDatabase.use {...}, for setting up a state before launching
         * the activity to test restoring of existing data by this activity.
         *
         * TestDatabaseFactory().readableDatabase.use {...}, for testing if data is is being saved
         *
         */
        inner class TestDatabaseFactory(
            context: Context? = activity,
            name: String? = "phrases.db",
            factory: SQLiteDatabase.CursorFactory? = null,
            version: Int = 1
        ) : SQLiteOpenHelper(context, name, factory, version) {
            var onCreateCalled = false
            var onUpgradeCalled = false
            var onOpenCalled = false

            override fun onCreate(database: SQLiteDatabase) {
                onCreateCalled = true
            }

            override fun onUpgrade(database: SQLiteDatabase, oldVersion: Int, newVersion: Int) {
                onUpgradeCalled = true
            }

            override fun onOpen(database: SQLiteDatabase) {
                onOpenCalled = true
            }

            @Synchronized
            override fun close() {
                onCreateCalled = false
                onUpgradeCalled = false
                onOpenCalled = false
                super.close()
            }
        }

        /**
         *  Makes assertions on the contents of one item of the RecyclerView.
         *
         *  Asserts that the the size of the list is at least itemIndex + 1.
         *
         *  Calls assertItem with the itemViewSupplier so that it is possible to make assertions on that itemView.
         *  Take attention to refresh references to views coming from itemView since RecyclerView
         *  can change the instance of View for a determinate list item after an update to the list.
         */
        fun RecyclerView.assertSingleListItem(itemIndex: Int, assertItem: (itemViewSupplier: () -> View) -> Unit) {

            assertNotNull("Your recycler view adapter should not be null", this.adapter)

            val expectedMinSize = itemIndex + 1

            val actualSize = this.adapter!!.itemCount
            assertTrue(
                "RecyclerView was expected to contain item with index $itemIndex, but its size was $actualSize",
                actualSize >= expectedMinSize
            )

            if(actualSize >= expectedMinSize) {
                val firstItemViewHolder = (0 until actualSize)
                    .asSequence()
                    .mapNotNull {  this.findViewHolderForAdapterPosition(it) }
                    .firstOrNull()
                    ?: throw AssertionError("No item is being displayed on songList RecyclerView, is it big enough to display one item?")

                val listHeight = firstItemViewHolder.itemView.height * (expectedMinSize + 1)
                this.layout(0,0, this.width, listHeight)  // may increase clock time

                val itemViewSupplier = {
                    this.scrollToPosition(itemIndex)
                    val itemView = (this.findViewHolderForAdapterPosition(itemIndex)?.itemView
                        ?: throw AssertionError("Could not find list item with index $itemIndex"))
                    itemView

                }

                assertItem(itemViewSupplier)

            } else {
                throw IllegalStateException("size assertion was not effective")
            }
        }

        /**
         * Use this method to find views.
         *
         * The view existence will be assert before being returned
         */
        inline fun <reified T> Dialog.findViewByString(idString: String): T {
            val id = this.context.resources.getIdentifier(idString, "id", context.packageName)
            val view: View? = this.findViewById(id)

            val idNotFoundMessage = "View with id \"$idString\" was not found"
            val wrongClassMessage = "View with id \"$idString\" is not from expected class. " +
                    "Expected ${T::class.java.simpleName} found ${view?.javaClass?.simpleName}"

            assertNotNull(idNotFoundMessage, view)
            assertTrue(wrongClassMessage, view is T)

            return view as T
        }
    }
  learner_created: false
- name: src/test/java/org/hyperskill/phrases/internals/CustomAsyncDifferConfigShadow.java
  visible: false
  text: |
    package org.hyperskill.phrases.internals;

    import android.os.Handler;
    import android.os.Looper;

    import androidx.recyclerview.widget.AsyncDifferConfig;

    import org.robolectric.annotation.Implementation;
    import org.robolectric.annotation.Implements;

    import java.util.concurrent.Executor;

    // version 1.1
    @Implements(AsyncDifferConfig.class)
    public class CustomAsyncDifferConfigShadow {

        public static class MainThreadExecutor implements Executor {
            private final Handler handler = new Handler(Looper.getMainLooper());

            @Override
            public void execute(Runnable r) {
                handler.post(r);
            }
        }
        Executor mainExecutor;

        @Implementation
        public Executor getBackgroundThreadExecutor() {
            if(mainExecutor == null) {
                mainExecutor = new MainThreadExecutor();
            }
            return mainExecutor;
        }
    }
  learner_created: false
- name: src/test/java/org/hyperskill/phrases/internals/PhrasesUnitTest.kt
  visible: false
  text: |
    package org.hyperskill.phrases.internals

    import android.app.*
    import android.app.AlarmManager.OnAlarmListener
    import android.content.ContentValues
    import android.content.Context
    import android.database.sqlite.SQLiteException
    import android.os.Handler
    import android.os.SystemClock
    import android.widget.EditText
    import android.widget.TextView
    import androidx.core.content.getSystemService
    import androidx.recyclerview.widget.RecyclerView
    import com.google.android.material.floatingactionbutton.FloatingActionButton
    import org.junit.Assert.*
    import org.robolectric.Shadows.shadowOf
    import org.robolectric.shadows.ShadowAlarmManager
    import org.robolectric.shadows.ShadowAlarmManager.ScheduledAlarm
    import org.robolectric.shadows.ShadowDialog
    import org.robolectric.shadows.ShadowNotificationManager
    import java.util.*
    import java.util.concurrent.TimeUnit

    // version 1.1
    open class PhrasesUnitTest<T : Activity>(clazz: Class<T>): AbstractUnitTest<T>(clazz) {

        @Suppress("UNUSED")
        companion object {
            const val CHANNEL_ID = "org.hyperskill.phrases"
            const val NOTIFICATION_ID = 393939
            val fakePhrases = listOf("This is a test phrase", "This is another test phrase", "Yet another test phrase")

            const val messagePhraseNotInDatabase: String =
                "The phrase in the notification is not equal to any phase in database."
            const val messageWrongDatabaseContent: String =
                "Make sure to load messages from database"
            const val messageNotificationWithIdNotFound =
                "Could not find notification with id 393939. Did you set the proper id?"
        }

        protected val reminderTv: TextView by lazy {
            val view = activity.findViewByString<TextView>("reminderTextView")
            val messageInitialText = "The reminderTextView has a wrong initial text"
            val expectedInitialText = "No reminder set"
            val actualInitialText = view.text.toString()
            assertEquals(messageInitialText, expectedInitialText, actualInitialText)

            view
        }

        protected val recyclerView : RecyclerView by lazy {
            activity.findViewByString("recyclerView")
        }

        protected val floatingButton: FloatingActionButton by lazy {
            activity.findViewByString("addButton")
        }

        protected val notificationManager: ShadowNotificationManager by lazy {
            shadowOf(
                activity.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
            )
        }

        protected fun RecyclerView.assertItemViewsExistOnItemWithIndex(index: Int = 0) {
            this.assertSingleListItem(index) { itemViewSupplier ->
                val itemView = itemViewSupplier()
                itemView.findViewByString<TextView>("phraseTextView")
            }
        }

        protected fun RecyclerView.assertAmountItems(expectedAmount: Int) {
            val actualInitialItems = this.adapter?.itemCount
                ?: throw AssertionError("Could not find any RecyclerView.Adapter on recyclerView")
            val messageInitialText = "The recyclerView doesn't have 3 or more items. Found $actualInitialItems items."
            assertTrue(messageInitialText, (actualInitialItems >= expectedAmount))
        }

        protected fun RecyclerView.deleteLastItemAndAssertSizeDecreased() {
            val adapter = this.adapter ?: throw AssertionError("Could not find any RecyclerView.Adapter on recyclerView")
            val beforeDeleteSize = adapter.itemCount
            val lastIndex = beforeDeleteSize - 1

            deletePhraseAtIndex(lastIndex)

            val expectedSizeAfterDelete = beforeDeleteSize - 1
            val actualSizeAfterDelete = adapter.itemCount

            assertEquals(
                "The recyclerView didn't remove item after clicking 'Delete'.",
                expectedSizeAfterDelete,
                actualSizeAfterDelete
            )
        }

        protected val notificationChannel: NotificationChannel by lazy {
            val notificationChannel =
                notificationManager.notificationChannels.mapNotNull {
                    it as NotificationChannel?
                }.firstOrNull {
                    it.id == CHANNEL_ID
                }

            assertNotNull("Couldn't find notification channel with ID \"$CHANNEL_ID\"", notificationChannel)
            notificationChannel!!
        }

        protected fun getLatestTimePickerDialog(notFoundMessage: String = "No TimePickerDialog was found"): TimePickerDialog {
            return ShadowDialog.getShownDialogs().mapNotNull {
                if(it is TimePickerDialog) it else null
            }.lastOrNull() ?: throw AssertionError(notFoundMessage)
        }

        protected fun TimePickerDialog.pickTime(hourOfDay: Int, minuteOfHour: Int, advanceClockMillis: Long = 500) {
            val shadowTimePickerDialog = shadowOf(this)

            this.updateTime(hourOfDay, minuteOfHour)
            shadowTimePickerDialog.clickOn(android.R.id.button1) // ok button
            shadowLooper.idleFor(advanceClockMillis, TimeUnit.MILLISECONDS)
        }

        fun runEnqueuedAlarms() {
            val alarmManager = activity.getSystemService<AlarmManager>()
            val shadowAlarmManager: ShadowAlarmManager = shadowOf(alarmManager)
            val toTrigger = shadowAlarmManager.scheduledAlarms.filter {
                it.triggerAtTime < SystemClock.currentGnssTimeClock().millis()
            }
            toTrigger.forEach { alarm ->
                // trigger alarm
                if(alarm.operation != null) {
                    val pendingIntent = shadowOf(alarm.operation)
                    if(alarm.triggerAtTime < SystemClock.currentGnssTimeClock().millis()) {
                        alarm.operation.intentSender.sendIntent(
                            pendingIntent.savedContext,
                            pendingIntent.requestCode,
                            pendingIntent.savedIntent,
                            null,
                            Handler(activity.mainLooper)
                        )
                        shadowLooper.idleFor(500, TimeUnit.MILLISECONDS)
                    }
                } else if(alarm.onAlarmListener != null) {
                    if(alarm.triggerAtTime < SystemClock.currentGnssTimeClock().millis()) {
                        alarm.onAlarmListener.onAlarm()
                    }
                }

                shadowAlarmManager.scheduledAlarms.remove(alarm) // remove triggered
                if(alarm.interval > 0) {
                    // if repeating schedule next
                    val nextAlarm = alarm.copy(triggerAtTime = alarm.triggerAtTime + alarm.interval)
                    shadowAlarmManager.scheduledAlarms.add(nextAlarm)
                }
            }
        }

        private fun ScheduledAlarm.copy(
            type: Int = this.type,
            triggerAtTime: Long = this.triggerAtTime,
            interval: Long = this.interval,
            operation: PendingIntent? = this.operation,
            showIntent: PendingIntent? = this.showIntent,
            onAlarmListener: OnAlarmListener? = this.onAlarmListener,
            handler: Handler? = this.handler
        ): ScheduledAlarm {
            val alarmConstructor = ScheduledAlarm::class.java.getDeclaredConstructor(
                Int::class.java,
                Long::class.java,
                Long::class.java,
                PendingIntent::class.java,
                PendingIntent::class.java,
                OnAlarmListener::class.java,
                Handler::class.java
            )
            alarmConstructor.isAccessible = true
            return alarmConstructor.newInstance(
                type,
                triggerAtTime,
                interval,
                operation,
                showIntent,
                onAlarmListener,
                handler
            )
        }

        protected fun addToDatabase(phrases: List<String>) {

            TestDatabaseFactory().writableDatabase.use { database ->
                database.execSQL("CREATE TABLE IF NOT EXISTS phrases (id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, phrase TEXT NOT NULL)")
                database.beginTransaction()
                try {
                    phrases.forEach {
                        ContentValues().apply {
                            put("phrase", it)
                            database.insert("phrases", null, this)
                        }
                    }
                    database.setTransactionSuccessful()
                } catch (ex: SQLiteException) {
                    ex.printStackTrace()
                    fail(ex.stackTraceToString())
                } catch (ex: IllegalStateException) {
                    ex.printStackTrace()
                    fail(ex.stackTraceToString())
                } finally {
                    database.endTransaction()
                }
            }
        }

        protected fun readAllFromDatabase(): List<String> {

            val phrasesFromDb = mutableListOf<String>()

            TestDatabaseFactory().readableDatabase.use { database ->
                database.query("phrases", null,
                    null, null, null, null, null).use { cursor ->

                    val phraseColumnIndex = cursor.getColumnIndex("phrase")
                    assertTrue("phrase column was not found", phraseColumnIndex >= 0)

                    while(cursor.moveToNext()) {
                        val phrase = cursor.getString(phraseColumnIndex)
                        phrasesFromDb.add(phrase)
                    }
                }
            }

            return phrasesFromDb
        }

        protected fun addPhrase(phrase: String) {
            floatingButton.clickAndRun()
            val dialog = ShadowDialog.getLatestDialog()
            val shadowDialog = shadowOf(dialog)
            assertNotNull("Are you sure you are showing a dialog when the floating button is clicked?", dialog)

            val editText = dialog.findViewByString<EditText>("editText")

            editText.setText(phrase)
            shadowDialog.clickOn(android.R.id.button1) // ok button
            shadowLooper.idleFor(500, TimeUnit.MILLISECONDS)
        }

        protected fun assertDatabaseContentMatchesList(messageWrongDatabaseContent: String, expectedDatabaseContent: List<String>) {
            val phrasesOnDatabase = readAllFromDatabase()

            assertEquals(messageWrongDatabaseContent,
                expectedDatabaseContent,
                phrasesOnDatabase
            )

            recyclerView.assertListItems(expectedDatabaseContent) { itemViewSupplier, index, phrase ->
                val itemView = itemViewSupplier()
                val phraseTextView = itemView.findViewByString<TextView>("phraseTextView")
                val actualPhrase = phraseTextView.text.toString()

                assertEquals(
                    "The recyclerView is not matching database content",
                    phrase,
                    actualPhrase
                )
            }
        }

        protected fun deletePhraseAtIndex(index: Int) {
            recyclerView.assertSingleListItem(index) { itemViewSupplier ->
                val itemView = itemViewSupplier()
                val deleteTextView = itemView.findViewByString<TextView>("deleteTextView")
                deleteTextView.clickAndRun()
            }
        }

        protected fun hourToMinutes(minutesFromNow: Int): Pair<Int, Int> {
            val calendar = Calendar.getInstance()
            calendar.add(Calendar.MINUTE, minutesFromNow)
            val hour = calendar.get(Calendar.HOUR_OF_DAY)
            val minute = calendar.get(Calendar.MINUTE)
            return hour to minute
        }
    }
  learner_created: false
- name: src/test/java/org/hyperskill/phrases/Stage2BUnitTest.kt
  visible: false
  text: |-
    package org.hyperskill.phrases

    import org.hyperskill.phrases.internals.CustomAsyncDifferConfigShadow
    import org.hyperskill.phrases.internals.PhrasesUnitTest
    import org.junit.FixMethodOrder
    import org.junit.Ignore
    import org.junit.Test
    import org.junit.runner.RunWith
    import org.junit.runners.MethodSorters
    import org.robolectric.RobolectricTestRunner
    import org.robolectric.annotation.Config

    // version 1.1
    @FixMethodOrder(MethodSorters.NAME_ASCENDING)
    @RunWith(RobolectricTestRunner::class)
    @Config(shadows = [CustomAsyncDifferConfigShadow::class])
    class Stage2BUnitTest : PhrasesUnitTest<MainActivity>(MainActivity::class.java){

        @Test
        fun test00_checkReminderTextViewExists() {
            testActivity {
                reminderTv
            }
        }

        @Test
        fun test01_checkFloatingButtonExists() {
            testActivity {
                floatingButton
            }
        }

        @Test
        fun test02_checkRecyclerViewExists() {
            testActivity {
                recyclerView
            }
        }

        @Test @Ignore("incompatible with stage4 requirements")
        fun test03_checkFirstListItemContainExpectedViews() {
            testActivity {
                recyclerView.assertItemViewsExistOnItemWithIndex(0)
            }
        }

        @Test @Ignore("incompatible with stage4 requirements")
        fun test04_checkRecyclerViewHasAtLeastThreeItems() {
            testActivity {
                recyclerView.assertAmountItems(3)
            }
        }

        @Test @Ignore("incompatible with stage4 requirements")
        fun test05_checkClickingDeleteDecreasesNumberOfItems() {
            testActivity {
                recyclerView.deleteLastItemAndAssertSizeDecreased()
            }
        }
    }
  learner_created: false
- name: src/test/java/org/hyperskill/phrases/Stage3UnitTest.kt
  visible: false
  text: |-
    package org.hyperskill.phrases

    import android.app.Notification
    import android.app.Notification.EXTRA_TEXT
    import android.app.Notification.EXTRA_TITLE
    import android.os.SystemClock
    import org.hyperskill.phrases.internals.CustomAsyncDifferConfigShadow
    import org.hyperskill.phrases.internals.PhrasesUnitTest
    import org.junit.Assert.*
    import org.junit.Before
    import org.junit.FixMethodOrder
    import org.junit.Test
    import org.junit.runner.RunWith
    import org.junit.runners.MethodSorters
    import org.robolectric.RobolectricTestRunner
    import org.robolectric.annotation.Config
    import java.util.concurrent.TimeUnit

    // version 1.1
    @FixMethodOrder(MethodSorters.NAME_ASCENDING)
    @RunWith(RobolectricTestRunner::class)
    @Config(shadows = [CustomAsyncDifferConfigShadow::class])
    class Stage3UnitTest : PhrasesUnitTest<MainActivity>(MainActivity::class.java){


        @Before
        fun setUp() {
            SystemClock.setCurrentTimeMillis(System.currentTimeMillis())
            run { // compatibility with stage4
                val phrases = listOf("database should not be empty to set reminder")
                addToDatabase(phrases)
            }
        }

        @Test
        fun test00_checkNotificationChannelExists() {
            testActivity {
                notificationChannel
            }
        }

        @Test
        fun test01_checkTimePickerDialog() {
            testActivity {
                reminderTv.clickAndRun()
                val timePickerDialog = getLatestTimePickerDialog()
                timePickerDialog.pickTime(10, 15)

                val expectedTimeText = "Reminder set for 10:15"
                val actualTimeText = reminderTv.text.toString()

                assertEquals("The reminderTextView has a wrong text", expectedTimeText, actualTimeText)
            }
        }

        @Test
        fun test02_checkTimeFormatting() {


            testActivity {
                val testCases = listOf(
                    0 to 0,
                    2 to 22,
                    12 to 6,
                    17 to 25,
                    23 to 59
                )

                val expectedTime = listOf(
                    "00:00",
                    "02:22",
                    "12:06",
                    "17:25",
                    "23:59"
                )

                testCases.forEachIndexed { i, (pickHour, pickMinute)  ->
                    reminderTv.clickAndRun()
                    val timePickerDialog = getLatestTimePickerDialog()

                    timePickerDialog.pickTime(pickHour, pickMinute)
                    val timeText = expectedTime[i]

                    val expectedText = "Reminder set for $timeText"
                    val actualText = reminderTv.text.toString()
                    assertEquals("Time is not formatted correctly", expectedText, actualText)
                }
            }
        }

        @Test
        fun test03_checkNotificationIsSent() {
            testActivity {
                val minutesToAdd = 10
                val (pickHour, pickMinute) = hourToMinutes(minutesFromNow = minutesToAdd)

                reminderTv.clickAndRun()
                val timePickerDialog = getLatestTimePickerDialog()
                timePickerDialog.pickTime(pickHour, pickMinute)

                runEnqueuedAlarms()
                val beforeTimeNotification: Notification? = notificationManager.getNotification(NOTIFICATION_ID)
                assertNull("Notification should not be sent before the time set", beforeTimeNotification)

                shadowLooper.idleFor(minutesToAdd + 2L, TimeUnit.MINUTES) // trigger alarm
                runEnqueuedAlarms()

                val notification: Notification? = notificationManager.getNotification(NOTIFICATION_ID)
                assertNotNull(messageNotificationWithIdNotFound, notification)
                notification!!

                val messageChannelId = "The notification channel id does not equals \"$CHANNEL_ID\""
                val actualChannelId = notification.channelId
                assertEquals(messageChannelId, CHANNEL_ID, actualChannelId)

                val messageTitle = "Have you set correct notification title?"
                val expectedTitle = "Your phrase of the day"
                val actualTitle = notification.extras.getCharSequence(EXTRA_TITLE)?.toString()
                assertEquals(messageTitle, expectedTitle, actualTitle)

                val messageContent = "Have you set the notification content?"
                val actualContent = notification.extras.getCharSequence(EXTRA_TEXT)?.toString()
                assertNotNull(messageContent, actualContent)
                assertTrue(messageContent, actualContent!!.isNotBlank())
            }
        }

        @Test
        fun test04_checkWhenTimeSetIsBeforeCurrentNotificationIsSentNextDay() {
            testActivity {
                val minutesToSubtract = 10
                val (pickHour, pickMinute) = hourToMinutes(minutesFromNow = -minutesToSubtract)

                reminderTv.clickAndRun()
                val timePickerDialog = getLatestTimePickerDialog()
                timePickerDialog.pickTime(pickHour, pickMinute)

                runEnqueuedAlarms()
                val beforeTimeNotification: Notification? = notificationManager.getNotification(NOTIFICATION_ID)
                val messageNotificationShouldBeNull =
                    "If the notification is set to a time before the current day time " +
                            "send the notification only next day"
                assertNull(messageNotificationShouldBeNull, beforeTimeNotification)


                shadowLooper.idleFor(1, TimeUnit.DAYS) // trigger alarm
                runEnqueuedAlarms()

                val notification: Notification? = notificationManager.getNotification(NOTIFICATION_ID)
                assertNotNull(messageNotificationWithIdNotFound, notification)
                notification!!

                val messageChannelId = "The notification channel id does not equals \"$CHANNEL_ID\""
                val actualChannelId = notification.channelId
                assertEquals(messageChannelId, CHANNEL_ID, actualChannelId)

                val messageTitle = "Have you set correct notification title?"
                val expectedTitle = "Your phrase of the day"
                val actualTitle = notification.extras.getCharSequence(EXTRA_TITLE)?.toString()
                assertEquals(messageTitle, expectedTitle, actualTitle)

                val messageContent = "Have you set the notification content?"
                val actualContent = notification.extras.getCharSequence(EXTRA_TEXT)?.toString()
                assertNotNull(messageContent, actualContent)
                assertTrue(messageContent, actualContent!!.isNotBlank())
            }
        }

        @Test
        fun test05_checkNotificationIsRepeating() {

            testActivity {
                val minutesToAdd = 10
                val (pickHour, pickMinute) = hourToMinutes(minutesFromNow = minutesToAdd)

                reminderTv.clickAndRun()
                val timePickerDialog = getLatestTimePickerDialog()
                timePickerDialog.pickTime(pickHour, pickMinute)

                shadowLooper.idleFor(minutesToAdd + 2L, TimeUnit.MINUTES) // trigger alarm
                runEnqueuedAlarms()

                val notification: Notification? = notificationManager.getNotification(NOTIFICATION_ID)
                assertNotNull(messageNotificationWithIdNotFound, notification)
                notification!!

                shadowLooper.idleFor(1 , TimeUnit.DAYS)
                shadowLooper.idleFor(10, TimeUnit.MINUTES)  // trigger alarm on next day
                runEnqueuedAlarms()

                val notification2: Notification? = notificationManager.getNotification(NOTIFICATION_ID)
                assertNotNull(messageNotificationWithIdNotFound, notification2)
                notification2!!

                val messageSameNotificationError =
                    "A new notification should be triggered on the next day"
                assertFalse(messageSameNotificationError, notification === notification2)
            }
        }
    }
  learner_created: false
- name: src/test/java/org/hyperskill/phrases/Stage4UnitTest.kt
  visible: false
  text: |-
    package org.hyperskill.phrases

    import android.app.Dialog
    import android.app.Notification
    import android.os.SystemClock
    import org.hyperskill.phrases.internals.CustomAsyncDifferConfigShadow
    import org.hyperskill.phrases.internals.PhrasesUnitTest
    import org.junit.Assert.*
    import org.junit.Before
    import org.junit.FixMethodOrder
    import org.junit.Test
    import org.junit.runner.RunWith
    import org.junit.runners.MethodSorters
    import org.robolectric.RobolectricTestRunner
    import org.robolectric.annotation.Config
    import org.robolectric.shadows.ShadowDialog
    import org.robolectric.shadows.ShadowToast
    import java.util.*
    import java.util.concurrent.TimeUnit

    // version 1.1
    @FixMethodOrder(MethodSorters.NAME_ASCENDING)
    @RunWith(RobolectricTestRunner::class)
    @Config(shadows = [CustomAsyncDifferConfigShadow::class])
    class Stage4UnitTest : PhrasesUnitTest<MainActivity>(MainActivity::class.java) {


        @Before
        fun setUp() {
            SystemClock.setCurrentTimeMillis(System.currentTimeMillis())
        }


        @Test
        fun test00_checkRecyclerViewIsUsingDatabase() {

            addToDatabase(fakePhrases)

            testActivity {
                assertDatabaseContentMatchesList(
                    messageWrongDatabaseContent = messageWrongDatabaseContent,
                    expectedDatabaseContent = fakePhrases
                )
            }
        }

        @Test
        fun test01_checkRecyclerViewIsUsingDatabase2() {

            val phrases = fakePhrases + "one more test phrase"
            addToDatabase(phrases)

            testActivity {
                assertDatabaseContentMatchesList(
                    messageWrongDatabaseContent = messageWrongDatabaseContent,
                    expectedDatabaseContent = phrases
                )
            }
        }

        @Test
        fun test02_checkAddDialog() {
            val phrases = listOf("A text for test")

            testActivity {
                addPhrase(phrases[0])

                assertDatabaseContentMatchesList(
                    messageWrongDatabaseContent = "Database content should contain added phrase",
                    expectedDatabaseContent = phrases
                )
            }
        }



        @Test
        fun test03_checkPhrasesAreDeleted() {

            addToDatabase(fakePhrases)

            testActivity {
                deletePhraseAtIndex(0)
                assertDatabaseContentMatchesList(
                    messageWrongDatabaseContent = "After deleting database content should be updated",
                    expectedDatabaseContent = fakePhrases.drop(1)
                )
            }
        }

        @Test
        fun test04_checkNotificationContainsPhraseFromDb() {

            addToDatabase(fakePhrases)

            testActivity {
                val minutesToAdd = 10
                val (pickHour, pickMinute) = hourToMinutes(minutesFromNow = minutesToAdd)

                reminderTv.clickAndRun()
                val timePickerDialog = getLatestTimePickerDialog()

                timePickerDialog.pickTime(pickHour, pickMinute)
                shadowLooper.idleFor(minutesToAdd + 2L, TimeUnit.MINUTES) // trigger alarm

                runEnqueuedAlarms()

                val notification: Notification? = notificationManager.getNotification(NOTIFICATION_ID)

                assertNotNull(messageNotificationWithIdNotFound, notification)
                notification!!

                val messageContent = messagePhraseNotInDatabase
                val actualContent = notification.extras.getCharSequence(Notification.EXTRA_TEXT)?.toString()
                assertTrue(messageContent, actualContent in fakePhrases)
            }
        }

        @Test
        fun test05_checkRemindersNotAllowedWithEmptyDatabase() {

            testActivity {
                reminderTv.clickAndRun()
                val maybeDialog: Dialog? = ShadowDialog.getLatestDialog()
                assertNull("No dialog should be shown if database is empty", maybeDialog)

                val toast = ShadowToast.getLatestToast()
                assertNotNull("Toast is not shown after trying to set reminder with empty database", toast)

                val expectedText = "No reminder set"
                val actualText = reminderTv.text.toString()
                assertEquals("Seems like reminder is still set with empty database", expectedText, actualText)
            }
        }

        @Test
        fun test06_checkEmptyAfterDeleteUnsetsReminder() {

            val fakePhrases = listOf("single item")
            addToDatabase(fakePhrases)

            testActivity {
                val minutesToAdd = 10
                val (pickHour, pickMinute) = hourToMinutes(minutesFromNow = minutesToAdd)


                reminderTv.clickAndRun()
                val timePickerDialog = getLatestTimePickerDialog()
                timePickerDialog.pickTime(pickHour, pickMinute)

                val unexpectedTextReminders = "No reminder set"
                val actualTextReminders = reminderTv.text.toString()
                assertNotEquals(
                    "If reminder is set reminderTv should change",
                    unexpectedTextReminders,
                    actualTextReminders
                )

                deletePhraseAtIndex(0)

                assertDatabaseContentMatchesList(
                    messageWrongDatabaseContent = "Database should be empty after deleting its only element",
                    expectedDatabaseContent = emptyList()
                )

                val expectedTextNoReminders = "No reminder set"
                val actualTextNoReminders = reminderTv.text.toString()
                assertEquals(
                    "If list becomes empty after deletion reminderTv should change",
                    expectedTextNoReminders,
                    actualTextNoReminders
                )

                val messageNotificationId =
                    "No notification should be triggered if the list is empty"

                try{
                    shadowLooper.idleFor(minutesToAdd + 2L, TimeUnit.MINUTES) // trigger alarm
                    runEnqueuedAlarms()
                    val notification: Notification? = notificationManager.getNotification(NOTIFICATION_ID)
                    assertNull(messageNotificationId, notification)
                } catch (noSuchElementException : NoSuchElementException) {
                    val exceptionThrownMessage = "Make sure you don't trigger alarm if the list is empty. " +
                            "$noSuchElementException"
                    throw AssertionError(exceptionThrownMessage, noSuchElementException)
                }
            }
        }

        @Test
        fun test07_checkNotificationSentOnNextDay() {
            addToDatabase(fakePhrases)

            testActivity {
                val minutesToAdd = 10
                val (pickHour, pickMinute) = hourToMinutes(minutesFromNow = minutesToAdd)

                reminderTv.clickAndRun()
                val timePickerDialog = getLatestTimePickerDialog()

                timePickerDialog.pickTime(pickHour, pickMinute)
                shadowLooper.idleFor(minutesToAdd + 2L, TimeUnit.MINUTES) // trigger alarm
                runEnqueuedAlarms()

                val notification: Notification? = notificationManager.getNotification(NOTIFICATION_ID)

                assertNotNull(messageNotificationWithIdNotFound, notification)
                notification!!

                val messageContent = messagePhraseNotInDatabase
                val actualContent = notification.extras.getCharSequence(Notification.EXTRA_TEXT)?.toString()
                assertTrue(messageContent, actualContent in fakePhrases)

                shadowLooper.idleFor(1 , TimeUnit.DAYS)
                shadowLooper.idleFor(10, TimeUnit.MINUTES)  // trigger alarm on next day
                runEnqueuedAlarms()

                val notification2: Notification? = notificationManager.getNotification(NOTIFICATION_ID)
                assertNotNull(messageNotificationWithIdNotFound, notification2)
                notification2!!

                val messageSameNotificationError =
                    "A new notification should be triggered on the next day"
                assertFalse(messageSameNotificationError, notification === notification2)

                val actualContent2 =
                    notification2.extras.getCharSequence(Notification.EXTRA_TEXT)?.toString()
                assertTrue(messagePhraseNotInDatabase, actualContent2 in fakePhrases)
            }
        }
    }
  learner_created: false
- name: build.gradle
  visible: false
  text: |-
    apply plugin: 'com.android.application'
    apply plugin: 'kotlin-android'
    apply plugin: 'kotlin-kapt'

    android {
        compileSdkVersion hs.android.compileSdkVersion

        defaultConfig {

            applicationId "org.hyperskill.phrases"
            minSdkVersion hs.android.minSdkVersion
            targetSdkVersion hs.android.targetSdkVersion
            versionCode 1
            versionName '1.0'
            kapt {
                arguments {
                    arg("room.schemaLocation", "$projectDir/schemas")
                }
            }
        }

        buildFeatures {
            viewBinding true
        }
    }

    dependencies {
        def kotlinVersion = hs.android.kotlinVersion
        implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk8:$kotlinVersion"

        def coreKtx = hs.android.lib.coreKtx
        implementation "androidx.core:core-ktx:$coreKtx"

        def appCompat = hs.android.lib.appCompat
        implementation "androidx.appcompat:appcompat:$appCompat"

        def constraintLayout = hs.android.lib.constraintLayout
        implementation "androidx.constraintlayout:constraintlayout:$constraintLayout"

        def material = hs.android.lib.material
        implementation "com.google.android.material:material:$material"

        def roomVersion = '2.3.0'
        kapt "androidx.room:room-compiler:$roomVersion"
        implementation "androidx.room:room-ktx:$roomVersion"
        implementation "androidx.room:room-runtime:$roomVersion"

        def lifecycleVersion = '2.2.0'
        implementation "androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycleVersion"
        implementation "androidx.lifecycle:lifecycle-livedata-ktx:$lifecycleVersion"

    }
  learner_created: false
- name: src/main/res/layout/item_phrase.xml
  visible: true
  learner_created: true
- name: src/main/java/org/hyperskill/phrases/Phrase.kt
  visible: true
  text: |+
    package org.hyperskill.phrases

    data class Phrase(val content: String)

  learner_created: true
- name: src/main/java/org/hyperskill/phrases/PhraseAdapter.kt
  visible: true
  text: |
    package org.hyperskill.phrases
    import android.content.Intent
    import android.view.LayoutInflater
    import android.view.View
    import android.view.ViewGroup
    import androidx.core.content.ContextCompat.startActivity
    import androidx.recyclerview.widget.LinearLayoutManager
    import androidx.recyclerview.widget.RecyclerView
    import org.hyperskill.phrases.databinding.*
    import kotlin.random.Random

    class BankPhrase(){
        private val phrasesList = listOf("A test phrase", "Another test phrase", "You wont believe what's coming, get ready: another test phrase")
        fun generateList(): ArrayList<Phrase>{
            val list = ArrayList<Phrase>()
            for (i in 0..phrasesList.size - 1 ) {
                list.add(
                    Phrase(phrasesList[i].toString())
                )
            }
            return list
        }

        fun randomPhrase(): String{
            var i = (0..2).random()
            return phrasesList[i]
        }


    }

    class PhraseAdapter: RecyclerView.Adapter<PhraseAdapter.PhraseHolder>(){
        var myPhrase = BankPhrase().generateList()

        class PhraseHolder(item : View): RecyclerView.ViewHolder(item) {
            val binding = ItemPhraseBinding.bind(item)
            fun bind(phrase: Phrase) = with(binding) {
                phraseTextView.text = phrase.content
            }
        }

        override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): PhraseHolder {
            val view = LayoutInflater.from(parent.context).inflate(R.layout.item_phrase, parent,false)
            return PhraseHolder(view)
        }

        override fun getItemCount(): Int {
            return  myPhrase.size
        }


        override fun onBindViewHolder(holder: PhraseHolder, position: Int) {
            holder.bind(myPhrase[position])

            var butDelete = holder.binding.deleteTextView
            butDelete.setOnClickListener {
                val pos = position
                if (pos >= 0 ){
                    //   Toast.makeText(holder.itemView.context, "$pos", Toast.LENGTH_SHORT).show()
                    myPhrase = ArrayList(myPhrase.filterIndexed { index, _ -> index != pos })
                    notifyItemRemoved(pos)
                }

            }
        }
    }

    fun openJetbrainsAcademy() {
        val url = "https://www.jetbrains.com/academy/"
        val intent = Intent(Intent.ACTION_VIEW, Uri.parse(url))

        try {
            startActivity(intent)
        } catch (e: Exception){
            handleActivityNotFound()
        }

    }
  learner_created: true
- name: src/main/java/org/hyperskill/phrases/AppDatabase.kt
  visible: true
  learner_created: true
- name: src/main/java/org/hyperskill/phrases/PhraseDao.kt
  visible: true
  learner_created: true
- name: src/main/java/org/hyperskill/phrases/AddPhrase.kt
  visible: true
  learner_created: true
- name: src/main/java/org/hyperskill/phrases/DeleteAlarm.kt
  visible: true
  learner_created: true
feedback_link: https://hyperskill.org/learn/step/23875#comment
status: Failed
feedback:
  message: "Exception. Test failed on activity execution with java.lang.NullPointerException:\
    \ Cannot invoke &quot;android.content.Context.getApplicationContext()&quot; because\
    \ &quot;this.mBase&quot; is null\njava.lang.NullPointerException: Cannot invoke\
    \ &quot;android.content.Context.getApplicationContext()&quot; because &quot;this.mBase&quot;\
    \ is null\n\tat android.content.ContextWrapper.getApplicationContext(ContextWrapper.java:118)\n\
    \tat org.hyperskill.phrases.AppDatabase$Companion.getDB(AppDatabase.kt:14)\n\t\
    at org.hyperskill.phrases.Receiver.onReceive(MainActivity.kt:32)\n\tat org.robolectric.shadows.ShadowBroadcastReceiver.onReceive(ShadowBroadcastReceiver.java:34)\n\
    \tat org.robolectric.shadows.ShadowBroadcastReceiver.onReceive(ShadowBroadcastReceiver.java:40)\n\
    \tat org.robolectric.shadows.ShadowInstrumentation$1.run(ShadowInstrumentation.java:376)\n\
    \tat android.os.Handler.handleCallback(Handler.java:883)\n\tat android.os.Handler.dispatchMessage(Handler.java:100)\n\
    \tat org.robolectric.shadows.ShadowPausedLooper$IdlingRunnable.run(ShadowPausedLooper.java:332)\n\
    \tat org.robolectric.shadows.ShadowPausedLooper.executeOnLooper(ShadowPausedLooper.java:366)\n\
    \tat org.robolectric.shadows.ShadowPausedLooper.idle(ShadowPausedLooper.java:92)\n\
    \tat org.robolectric.shadows.ShadowPausedLooper.idleFor(ShadowPausedLooper.java:101)\n\
    \tat org.hyperskill.phrases.internals.PhrasesUnitTest.runEnqueuedAlarms(PhrasesUnitTest.kt:140)\n\
    \tat org.hyperskill.phrases.Stage3UnitTest$test04_checkWhenTimeSetIsBeforeCurrentNotificationIsSentNextDay$1.invoke(Stage3UnitTest.kt:147)\n\
    \tat org.hyperskill.phrases.Stage3UnitTest$test04_checkWhenTimeSetIsBeforeCurrentNotificationIsSentNextDay$1.invoke(Stage3UnitTest.kt:130)\n\
    \tat org.hyperskill.phrases.internals.AbstractUnitTest.testActivity(AbstractUnitTest.kt:87)\n\
    \tat org.hyperskill.phrases.internals.AbstractUnitTest.testActivity$default(AbstractUnitTest.kt:78)\n\
    \tat org.hyperskill.phrases.Stage3UnitTest.test04_checkWhenTimeSetIsBeforeCurrentNotificationIsSentNextDay(Stage3UnitTest.kt:130)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:59)\n\
    \tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n\
    \tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:56)\n\
    \tat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\n\
    \tat org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)\n\
    \tat org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)\n\tat org.robolectric.RobolectricTestRunner$HelperTestRunner$1.evaluate(RobolectricTestRunner.java:591)\n\
    \tat org.robolectric.internal.SandboxTestRunner$2.lambda$evaluate$0(SandboxTestRunner.java:274)\n\
    \tat org.robolectric.internal.bytecode.Sandbox.lambda$runOnMainThread$0(Sandbox.java:88)\n\
    \tat java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)\n\tat\
    \ java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)\n\
    \tat java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)\n\
    \tat java.base/java.lang.Thread.run(Thread.java:833)"
  time: "Sat, 29 Apr 2023 18:22:32 UTC"
record: -1
